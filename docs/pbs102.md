# PBS 102 of X — Introducing Git

In the previous instalment we introduced the concept of version control systems (VCS), and we described the two broad categories they fall into — client-server, and peer-to-peer or distributed. We explained why we'd be focusing on distributed version control in this series, and why I chose to explore those concepts using Git. We also laid out a big-picture roadmap for this series-within-a-series, starting with local repositories, then private remote repositories for backup and easy access, and finally shared repositories for collaboration.

In this instalment we're going to focus on the underlying design of Git — what does it actually store, how does it represent it, and what words does it use to describe it. Trying to learn the Git commands, or even to use a Git GUI without an understanding of Git Jargon is a recipe for confusion and frustration! I want to nip that in the bud by laying a strong foundation we can then build on.

PLAYER GOES HERE

Before we get serious, let's take a moment to look at the name *Git*, does it mean anything? The short answer is *'not really'*. It's not an acronym, hence it not being all uppercase, and its author, Linux Torvalds likes to say it can mean what ever you want it to mean, or what ever fits your current mood.

In Irish and British English a *git* is an *unpleasant person* (that's a little understated), and its author joked:

> I'm an egotistical bastard, and I name all my projects after myself. First 'Linux', now 'git'.

The `git` command's man page describes Git as *the stupid content tracker*.

The README file that ships with the Git source code offers a collection of different definitions to match your mood:

* random three-letter combination that is pronounceable, and not actually used by any common UNIX command. The fact that it is a mispronunciation of *get* may or may not be relevant.
* stupid. contemptible and despicable. simple. Take your pick from the dictionary of slang.
* *global information tracker*: you're in a good mood, and it actually works for you. Angels sing, and a light suddenly fills the room.
* *"goddamn idiotic truckload of shit"*: when it breaks

Where ever the name comes from, no one seems too previous about it, which is a nice change in the world of nerdery, where something as innocuous as expressing a preference for `vi` over `emacs` can kick off a vicious troll war!

## A Git Repository

A Git Repository contains the full version history of a single project along with all its related metadata, and some configuration parameters.

Git repositories are designed to be quickly and efficiently copied, or *cloned* to use the Git jargon. When you clone a git repository the full history and all the metadata get copied, but the configuration parameters don't. This is important, because those configuration parameters are what allow you to personalise your copy of a repository. They hold information like your name, email address, and the remote copies of the repository you want to collaborate with.

On your computer, a Git repository is simply a folder with a well defined structure.

Conceptually, a Git repository consists of a number of parts, some permanent, others not.

1. **The Database** — the collection of objects that represents the entire committed version history of a project. This database is stored in a hidden folder named `.git` at the repository's root.
2. **The Working Copy** — the current state of the project, basically the visible content of the repository
3. **The Index** — a temporary data structure that represents the changes between the last committed version and the current working copy. The index keeps track of information about the changes you are making, and is used to build a version of your project for storage in the database when you *commit* some of all of your changes.

## The Git Database

The Git database stores the entire history of a project as a collection of objects, and these object come in just four types:

1. **Blobs** — a blob is basically the contents of a file. They only contain data, and don't have a name in the traditional sense, being referenced by a hash of their content instead. Naming blobs based on their contents avoids duplication. If the same piece of data appears many times in a project's history it's only saved once, but referenced many times.
2. **Trees** — a tree is analogous to a folder in a traditional file system. A tree object maps names to blobs and other trees. The recursive nature of that definition allows for an effectively infinite folder depth.
3. **Commits** — a commit represents a point in time in a project's history, a snapshot if you will. A commit uses a tree object to capture the state of all the files and folders in the projects. As well as this tree a commit also contains a lot of metadata, including things like the author, the date, and an optional message describing the changes. Commits are named based on a hash of their contents.
4. **Tags** — tags are used to assign human-friendly names to other objects, usually commits.
